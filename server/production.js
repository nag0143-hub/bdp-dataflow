import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import compression from 'compression';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { initializeDatabase, pool, entityNameToTable, sanitizeFieldName, config } from './db.js';
import { testConnection } from './test-connection.js';
import airflowRouter from './airflow-proxy.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const app = express();
const PORT = config.server.port;
const startTime = Date.now();

app.use(compression());

app.use(helmet({
  contentSecurityPolicy: false,
  crossOriginEmbedderPolicy: false,
}));

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_MAX || '1000', 10),
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many requests, please try again later.' },
});
app.use('/api/', apiLimiter);

const writeLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_WRITE_MAX || '200', 10),
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many write requests, please try again later.' },
});
app.use('/api/entities/:entityName', (req, res, next) => {
  if (req.method === 'DELETE') return writeLimiter(req, res, next);
  if ((req.method === 'POST' || req.method === 'PUT') && !req.url.includes('/filter')) return writeLimiter(req, res, next);
  next();
});

app.use(express.json({ limit: config.api.bodyLimit }));

app.use((req, res, next) => {
  const origin = config.cors.origin;
  res.header('Access-Control-Allow-Origin', origin);
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (config.cors.credentials) res.header('Access-Control-Allow-Credentials', 'true');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

if (config.logging.requests) {
  app.use((req, res, next) => {
    const start = Date.now();
    res.on('finish', () => {
      console.log(`${req.method} ${req.url} ${res.statusCode} ${Date.now() - start}ms`);
    });
    next();
  });
}

function clampPageSize(value, fallback) {
  const num = parseInt(value) || fallback || config.api.defaultPageSize;
  return Math.min(Math.max(1, num), config.api.maxPageSize);
}

function formatRecord(row) {
  return {
    id: String(row.id),
    ...row.data,
    created_date: row.created_date,
    updated_date: row.updated_date,
    created_by: row.created_by
  };
}

function buildFilterClause(query, params) {
  if (!query || Object.keys(query).length === 0) return { where: '', params };
  const conditions = [];
  let paramIndex = params.length;

  function processFilter(filter) {
    for (const [key, value] of Object.entries(filter)) {
      if (key === '$or' && Array.isArray(value)) {
        const orConditions = [];
        for (const subFilter of value) {
          const subConditions = [];
          for (const [subKey, subValue] of Object.entries(subFilter)) {
            if (subValue && typeof subValue === 'object' && '$regex' in subValue) {
              paramIndex++;
              subConditions.push(`data->>'${sanitizeFieldName(subKey)}' ~* $${paramIndex}`);
              params.push(subValue.$regex);
            } else {
              paramIndex++;
              subConditions.push(`data->>'${sanitizeFieldName(subKey)}' = $${paramIndex}`);
              params.push(String(subValue));
            }
          }
          if (subConditions.length > 0) orConditions.push(`(${subConditions.join(' AND ')})`);
        }
        if (orConditions.length > 0) conditions.push(`(${orConditions.join(' OR ')})`);
      } else if (value && typeof value === 'object' && '$regex' in value) {
        paramIndex++;
        conditions.push(`data->>'${sanitizeFieldName(key)}' ~* $${paramIndex}`);
        params.push(value.$regex);
      } else if (value && typeof value === 'object' && '$in' in value) {
        paramIndex++;
        conditions.push(`data->>'${sanitizeFieldName(key)}' = ANY($${paramIndex})`);
        params.push(value.$in.map(String));
      } else if (value && typeof value === 'object' && '$ne' in value) {
        paramIndex++;
        conditions.push(`(data->>'${sanitizeFieldName(key)}' IS NULL OR data->>'${sanitizeFieldName(key)}' != $${paramIndex})`);
        params.push(String(value.$ne));
      } else if (value && typeof value === 'object' && '$exists' in value) {
        if (value.$exists) conditions.push(`data ? '${sanitizeFieldName(key)}'`);
        else conditions.push(`NOT (data ? '${sanitizeFieldName(key)}')`);
      } else {
        paramIndex++;
        conditions.push(`data->>'${sanitizeFieldName(key)}' = $${paramIndex}`);
        params.push(String(value));
      }
    }
  }

  processFilter(query);
  return {
    where: conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '',
    params
  };
}

function buildSortClause(sort) {
  if (!sort) return 'ORDER BY created_date DESC';
  const desc = sort.startsWith('-');
  const field = desc ? sort.substring(1) : sort;
  if (field === 'created_date' || field === 'updated_date') {
    return `ORDER BY ${field} ${desc ? 'DESC' : 'ASC'}`;
  }
  return `ORDER BY data->>'${sanitizeFieldName(field)}' ${desc ? 'DESC' : 'ASC'} NULLS LAST`;
}

async function searchEntities(table, searchTerm, filters, limit = 50) {
  const params = [];
  const conditions = [];
  let paramIndex = 0;
  if (filters) {
    for (const [key, value] of Object.entries(filters)) {
      if (value !== undefined && value !== null && value !== '') {
        paramIndex++;
        conditions.push(`data->>'${sanitizeFieldName(key)}' = $${paramIndex}`);
        params.push(String(value));
      }
    }
  }
  if (searchTerm) {
    paramIndex++;
    conditions.push(`to_tsvector('english', data::text) @@ plainto_tsquery('english', $${paramIndex})`);
    params.push(searchTerm);
  }
  const where = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
  paramIndex++;
  params.push(parseInt(limit));
  const result = await pool.query(
    `SELECT * FROM "${table}" ${where} ORDER BY created_date DESC LIMIT $${paramIndex}`,
    params
  );
  return result.rows.map(formatRecord);
}

app.get('/api/health', async (req, res) => {
  try {
    const dbCheck = await pool.query('SELECT 1');
    res.json({
      status: 'ok',
      uptime: Math.floor((Date.now() - startTime) / 1000),
      database: dbCheck ? 'connected' : 'error',
      timestamp: new Date().toISOString(),
    });
  } catch (err) {
    res.status(503).json({
      status: 'degraded',
      uptime: Math.floor((Date.now() - startTime) / 1000),
      database: 'disconnected',
      error: err.message,
      timestamp: new Date().toISOString(),
    });
  }
});

app.get('/api/auth/me', (req, res) => {
  res.json({ ...config.auth.mockUser, is_authenticated: true });
});

app.post('/api/auth/logout', (req, res) => res.json({ success: true }));

app.get('/api/apps/public/prod/public-settings/by-id/:appId', (req, res) => {
  res.json({ appId: req.params.appId, name: 'DataFlow', requiresAuth: false, status: 'active' });
});

app.get('/api/entities/:entityName', async (req, res) => {
  try {
    const table = entityNameToTable(req.params.entityName);
    const { sort, limit, skip = '0' } = req.query;
    const result = await pool.query(
      `SELECT * FROM "${table}" ${buildSortClause(sort)} LIMIT $1 OFFSET $2`,
      [clampPageSize(limit), parseInt(skip) || 0]
    );
    res.json(result.rows.map(formatRecord));
  } catch (err) {
    if (err.code === '42P01') return res.json([]);
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/entities/:entityName/filter', async (req, res) => {
  try {
    const table = entityNameToTable(req.params.entityName);
    const { query: filterQuery, sort, limit, skip = 0 } = req.body;
    const params = [];
    const { where, params: filterParams } = buildFilterClause(filterQuery, params);
    const paramIdx = filterParams.length;
    filterParams.push(clampPageSize(limit), parseInt(skip) || 0);
    const result = await pool.query(
      `SELECT * FROM "${table}" ${where} ${buildSortClause(sort)} LIMIT $${paramIdx + 1} OFFSET $${paramIdx + 2}`,
      filterParams
    );
    res.json(result.rows.map(formatRecord));
  } catch (err) {
    if (err.code === '42P01') return res.json([]);
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/entities/:entityName/:id', async (req, res) => {
  try {
    const table = entityNameToTable(req.params.entityName);
    const result = await pool.query(`SELECT * FROM "${table}" WHERE id = $1`, [parseInt(req.params.id)]);
    if (result.rows.length === 0) return res.status(404).json({ error: 'Not found' });
    res.json(formatRecord(result.rows[0]));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/entities/:entityName', async (req, res) => {
  try {
    const table = entityNameToTable(req.params.entityName);
    const data = { ...req.body };
    const createdBy = data.created_by || 'user@local';
    delete data.created_by;
    const result = await pool.query(
      `INSERT INTO "${table}" (data, created_by) VALUES ($1, $2) RETURNING *`,
      [JSON.stringify(data), createdBy]
    );
    res.status(201).json(formatRecord(result.rows[0]));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.put('/api/entities/:entityName/:id', async (req, res) => {
  try {
    const table = entityNameToTable(req.params.entityName);
    const data = { ...req.body };
    delete data.id; delete data.created_date; delete data.updated_date; delete data.created_by;
    const result = await pool.query(
      `UPDATE "${table}" SET data = data || $1, updated_date = NOW() WHERE id = $2 RETURNING *`,
      [JSON.stringify(data), parseInt(req.params.id)]
    );
    if (result.rows.length === 0) return res.status(404).json({ error: 'Not found' });
    res.json(formatRecord(result.rows[0]));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.delete('/api/entities/:entityName/:id', async (req, res) => {
  try {
    const table = entityNameToTable(req.params.entityName);
    await pool.query(`DELETE FROM "${table}" WHERE id = $1`, [parseInt(req.params.id)]);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.use('/api/airflow', airflowRouter);

app.post('/api/test-connection', async (req, res) => {
  try {
    const result = await testConnection(req.body);
    res.json(result);
  } catch (err) {
    res.status(500).json({
      success: false,
      error_code: 'INTERNAL_ERROR',
      error_message: err.message,
      latency_ms: 0,
    });
  }
});

app.post('/api/validate-spec', async (req, res) => {
  try {
    const { validateSpecWithDB } = await import('./spec-validator.js');
    const spec = req.body.spec || req.body;
    const results = await validateSpecWithDB(spec, pool, entityNameToTable);
    res.json({ ...results, checked_at: new Date().toISOString() });
  } catch (err) {
    res.status(500).json({ valid: false, errors: [{ path: "", message: err.message, severity: "error" }], warnings: [], checked_at: new Date().toISOString() });
  }
});

app.post('/api/introspect-schema', async (req, res) => {
  try {
    const { connectionId } = req.body;
    const parsedId = parseInt(connectionId);
    if (!connectionId || isNaN(parsedId)) {
      return res.status(400).json({ success: false, error: 'A valid numeric connectionId is required' });
    }
    const table = entityNameToTable('Connection');
    const result = await pool.query('SELECT data FROM "' + table + '" WHERE id = $1', [parsedId]);
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    const connData = result.rows[0].data;
    const { introspectSchema } = await import('./introspect-schema.js');
    const schemas = await introspectSchema(connData);
    res.json(schemas);
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/functions/:functionName', async (req, res) => {
  const { functionName } = req.params;
  try {
    switch (functionName) {
      case 'searchPipelines': {
        const { searchTerm, filters, limit } = req.body;
        res.json(await searchEntities('pipeline', searchTerm, filters, limit));
        break;
      }
      case 'searchConnections': {
        const { searchTerm, filters, limit } = req.body;
        res.json(await searchEntities('connection', searchTerm, filters, limit));
        break;
      }
      case 'searchActivityLogs': {
        const { searchTerm, filters, limit } = req.body;
        const items = await searchEntities('activity_log', searchTerm, filters, limit);
        res.json({ items, nextCursor: null, hasMore: false });
        break;
      }
      case 'fetchVaultCredentials':
        res.json({ error: 'Vault not configured in local environment' });
        break;
      case 'generateLineage':
        res.json({ error: 'Lineage feature has been removed' });
        break;
      case 'syncAirflowDagsAsync':
        res.json({ status: 'sync_not_available', message: 'Airflow sync not configured in local environment' });
        break;
      case 'triggerDependentPipelines':
        res.json({ triggered: [] });
        break;
      default:
        res.status(404).json({ error: `Function '${functionName}' not found` });
    }
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.use('/', express.static(path.join(__dirname, '..', 'dist')));

app.use('/', (req, res) => {
  res.sendFile(path.join(__dirname, '..', 'dist', 'index.html'));
});

async function start() {
  await initializeDatabase();
  app.listen(PORT, config.server.host, () => {
    console.log(`Production server running on http://${config.server.host}:${PORT}`);
  });
}

start().catch(err => {
  console.error('Failed to start:', err);
  process.exit(1);
});
